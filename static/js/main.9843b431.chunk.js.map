{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","Algorithms/dijkstra.jsx","Algorithms/astar.jsx","PathfindingVisualizer/PathfindingVisualizer.jsx","Algorithms/bfs.jsx","Algorithms/dfs.jsx","Algorithms/bogo.jsx","Algorithms/spread.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","astar","sortByDistance","distanceToFinishNode","PathfindingVisualizer","getInitialGrid","rowCount","state","ROW_COUNT","colCount","COLUMN_COUNT","initialGrid","currentRow","createNode","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","Math","abs","isNode","mouseIsPressed","MOBILE_ROW_COUNT","MOBILE_COLUMN_COUNT","isRunning","isStartNode","isFinishNode","isWallNode","currRow","currCol","isDesktopView","algoNum","handleMouseDown","bind","handleMouseLeave","toggleIsRunning","setState","clearGrid","clearWalls","alert","isGridClear","document","getElementById","newGrid","getNewGridWithWallToggled","nodeClassName","slice","algo","nextNodesStack","currentNode","nextNode","bfs","pop","dfs","getRandomInt","max","floor","random","bogo","spread","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","animate","i","setTimeout","animateShortestPath","Algos","titles","descriptions","links","href","type","class","style","width","marginTop","color","onClick","visualize","toggleView","onMouseLeave","map","rowIdx","nodeIdx","handleMouseEnter","handleMouseUp","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.9843b431.chunk.js","sourcesContent":["import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n    } = this.props;\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : \"\";\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n","// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\n\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n","// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\n\nexport function astar(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid); // Q: different from using grid or slice of grid???\n\n  while (unvisitedNodes.length) {\n    sortByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (!closestNode.isWall) {\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should stop.\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      updateUnvisitedNeighbors(closestNode, grid);\n    }\n  }\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nfunction sortByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1 + neighbor.distanceToFinishNode;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport { dijkstra } from \"../Algorithms/dijkstra\";\nimport { astar } from \"../Algorithms/astar\";\nimport { dfs } from \"../Algorithms/dfs\";\nimport { bfs } from \"../Algorithms/bfs\";\nimport { bogo } from \"../Algorithms/bogo\";\nimport { spread } from \"../Algorithms/spread\";\n\nimport \"./PathfindingVisualizer.css\";\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      START_NODE_ROW: 5,\n      FINISH_NODE_ROW: 9,\n      START_NODE_COL: 5,\n      FINISH_NODE_COL: 19,\n      mouseIsPressed: false,\n      ROW_COUNT: 25,\n      COLUMN_COUNT: 35,\n      MOBILE_ROW_COUNT: 10,\n      MOBILE_COLUMN_COUNT: 20,\n      isRunning: false,\n      isStartNode: false,\n      isFinishNode: false,\n      isWallNode: false, // xxxxxxx\n      currRow: 0,\n      currCol: 0,\n      isDesktopView: true,\n      algoNum: 0,\n    };\n\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\n  }\n\n  componentDidMount() {\n    const grid = this.getInitialGrid();\n    this.setState({ grid });\n  }\n\n  toggleIsRunning() {\n    this.setState({ isRunning: !this.state.isRunning });\n  }\n\n  toggleView() {\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.clearWalls();\n      const isDesktopView = !this.state.isDesktopView;\n      let grid;\n      if (isDesktopView) {\n        grid = this.getInitialGrid(\n          this.state.ROW_COUNT,\n          this.state.COLUMN_COUNT\n        );\n        this.setState({ isDesktopView, grid });\n      } else {\n        if (\n          this.state.START_NODE_ROW > this.state.MOBILE_ROW_COUNT ||\n          this.state.FINISH_NODE_ROW > this.state.MOBILE_ROW_COUNT ||\n          this.state.START_NODE_COL > this.state.MOBILE_COLUMN_COUNT ||\n          this.state.FINISH_NODE_COL > this.state.MOBILE_COLUMN_COUNT\n        ) {\n          alert(\"Start & Finish Nodes Must Be within 10 Rows x 20 Columns\");\n        } else {\n          grid = this.getInitialGrid(\n            this.state.MOBILE_ROW_COUNT,\n            this.state.MOBILE_COLUMN_COUNT\n          );\n          this.setState({ isDesktopView, grid });\n        }\n      }\n    }\n  }\n\n  /******************** Set up the initial grid ********************/\n  getInitialGrid = (\n    rowCount = this.state.ROW_COUNT,\n    colCount = this.state.COLUMN_COUNT\n  ) => {\n    const initialGrid = [];\n    for (let row = 0; row < rowCount; row++) {\n      const currentRow = [];\n      for (let col = 0; col < colCount; col++) {\n        currentRow.push(this.createNode(row, col));\n      }\n      initialGrid.push(currentRow);\n    }\n    return initialGrid;\n  };\n\n  createNode = (row, col) => {\n    return {\n      row,\n      col,\n      isStart:\n        row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\n      isFinish:\n        row === this.state.FINISH_NODE_ROW &&\n        col === this.state.FINISH_NODE_COL,\n      distance: Infinity,\n      distanceToFinishNode:\n        Math.abs(this.state.FINISH_NODE_ROW - row) +\n        Math.abs(this.state.FINISH_NODE_COL - col),\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n      isNode: true,\n    };\n  };\n\n  /******************** Control mouse events ********************/\n  handleMouseDown(row, col) {\n    if (!this.state.isRunning) {\n      if (this.isGridClear()) {\n        if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          \"node node-start\"\n        ) {\n          this.setState({\n            mouseIsPressed: true,\n            isStartNode: true,\n            currRow: row,\n            currCol: col,\n          });\n        } else if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          \"node node-finish\"\n        ) {\n          this.setState({\n            mouseIsPressed: true,\n            isFinishNode: true,\n            currRow: row,\n            currCol: col,\n          });\n        } else {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid,\n            mouseIsPressed: true,\n            isWallNode: true,\n            currRow: row,\n            currCol: col,\n          });\n        }\n      } else {\n        this.clearGrid();\n      }\n    }\n  }\n\n  isGridClear() {\n    for (const row of this.state.grid) {\n      for (const node of row) {\n        const nodeClassName = document.getElementById(\n          `node-${node.row}-${node.col}`\n        ).className;\n        if (\n          nodeClassName === \"node node-visited\" ||\n          nodeClassName === \"node node-shortest-path\"\n        ) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.isRunning) {\n      if (this.state.mouseIsPressed) {\n        const nodeClassName = document.getElementById(\n          `node-${row}-${col}`\n        ).className;\n        if (this.state.isStartNode) {\n          if (nodeClassName !== \"node node-wall\") {\n            const prevStartNode =\n              this.state.grid[this.state.currRow][this.state.currCol];\n            prevStartNode.isStart = false;\n            document.getElementById(\n              `node-${this.state.currRow}-${this.state.currCol}`\n            ).className = \"node\";\n\n            this.setState({ currRow: row, currCol: col });\n            const currStartNode = this.state.grid[row][col];\n            currStartNode.isStart = true;\n            document.getElementById(`node-${row}-${col}`).className =\n              \"node node-start\";\n          }\n          this.setState({ START_NODE_ROW: row, START_NODE_COL: col });\n        } else if (this.state.isFinishNode) {\n          if (nodeClassName !== \"node node-wall\") {\n            const prevFinishNode =\n              this.state.grid[this.state.currRow][this.state.currCol];\n            prevFinishNode.isFinish = false;\n            document.getElementById(\n              `node-${this.state.currRow}-${this.state.currCol}`\n            ).className = \"node\";\n\n            this.setState({ currRow: row, currCol: col });\n            const currFinishNode = this.state.grid[row][col];\n            currFinishNode.isFinish = true;\n            document.getElementById(`node-${row}-${col}`).className =\n              \"node node-finish\";\n          }\n          this.setState({ FINISH_NODE_ROW: row, FINISH_NODE_COL: col });\n        } else if (this.state.isWallNode) {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({ grid: newGrid });\n        }\n      }\n    }\n  }\n\n  handleMouseUp(row, col) {\n    if (!this.state.isRunning) {\n      this.setState({ mouseIsPressed: false });\n      if (this.state.isStartNode) {\n        const isStartNode = !this.state.isStartNode;\n        this.setState({\n          isStartNode,\n          START_NODE_ROW: row,\n          START_NODE_COL: col,\n        });\n      } else if (this.state.isFinishNode) {\n        const isFinishNode = !this.state.isFinishNode;\n        this.setState({\n          isFinishNode,\n          FINISH_NODE_ROW: row,\n          FINISH_NODE_COL: col,\n        });\n      }\n      this.getInitialGrid();\n    }\n  }\n\n  handleMouseLeave() {\n    if (this.state.isStartNode) {\n      const isStartNode = !this.state.isStartNode;\n      this.setState({ isStartNode, mouseIsPressed: false });\n    } else if (this.state.isFinishNode) {\n      const isFinishNode = !this.state.isFinishNode;\n      this.setState({ isFinishNode, mouseIsPressed: false });\n    } else if (this.state.isWallNode) {\n      const isWallNode = !this.state.isWallNode;\n      this.setState({ isWallNode, mouseIsPressed: false });\n      this.getInitialGrid();\n    }\n  }\n\n  /******************** Clear Board/Walls ********************/\n\n  clearGrid() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(\n            `node-${node.row}-${node.col}`\n          ).className;\n          if (\n            nodeClassName !== \"node node-start\" &&\n            nodeClassName !== \"node node-finish\" &&\n            nodeClassName !== \"node node-wall\"\n          ) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              \"node\";\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode =\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\n          }\n          if (nodeClassName === \"node node-finish\") {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = 0;\n          }\n          if (nodeClassName === \"node node-start\") {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode =\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\n            node.isStart = true;\n            node.isWall = false;\n            node.previousNode = null;\n            node.isNode = true;\n          }\n        }\n      }\n    }\n  }\n\n  clearWalls() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(\n            `node-${node.row}-${node.col}`\n          ).className;\n          if (nodeClassName === \"node node-wall\") {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              \"node\";\n            node.isWall = false;\n          }\n        }\n      }\n    }\n  }\n\n  /******************** Create Animations ********************/\n  visualize(algo) {\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.toggleIsRunning();\n      const { grid } = this.state;\n      const startNode =\n        grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n      const finishNode =\n        grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n      let visitedNodesInOrder;\n      switch (algo) {\n        case \"Dijkstra\":\n          visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n          this.setState({ algoNum: 0 });\n          break;\n        case \"AStar\":\n          visitedNodesInOrder = astar(grid, startNode, finishNode);\n          this.setState({ algoNum: 1 });\n          break;\n        case \"BFS\":\n          visitedNodesInOrder = bfs(grid, startNode, finishNode);\n          this.setState({ algoNum: 2 });\n          break;\n        case \"DFS\":\n          visitedNodesInOrder = dfs(grid, startNode, finishNode);\n          this.setState({ algoNum: 3 });\n          break;\n        case \"Bogo\":\n          visitedNodesInOrder = bogo(grid, startNode, finishNode);\n          this.setState({ algoNum: 4 });\n          break;\n        case \"Spread\":\n          visitedNodesInOrder = spread(grid, startNode, finishNode);\n          this.setState({ algoNum: 5 });\n          break;\n        default:\n          // should never get here\n          break;\n      }\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n      nodesInShortestPathOrder.push(\"end\");\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n    }\n  }\n\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const nodeClassName = document.getElementById(\n          `node-${node.row}-${node.col}`\n        ).className;\n        if (\n          nodeClassName !== \"node node-start\" &&\n          nodeClassName !== \"node node-finish\"\n        ) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visited\";\n        }\n      }, 10 * i);\n    }\n  }\n\n  /******************** Create path from start to finish ********************/\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      if (nodesInShortestPathOrder[i] === \"end\") {\n        setTimeout(() => {\n          this.toggleIsRunning();\n        }, i * 50);\n      } else {\n        setTimeout(() => {\n          const node = nodesInShortestPathOrder[i];\n          const nodeClassName = document.getElementById(\n            `node-${node.row}-${node.col}`\n          ).className;\n          if (\n            nodeClassName !== \"node node-start\" &&\n            nodeClassName !== \"node node-finish\"\n          ) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              \"node node-shortest-path\";\n          }\n        }, i * 40);\n      }\n    }\n  }\n\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n    const Algos = {\n      titles: [\n        \"Dijkstra's Shortest Path Algorithm\",\n        \"A* Search Algorithm\",\n        \"Breadth First Search\",\n        \"Depth First Search\",\n        \"Bogo Search\",\n        \"Random Spread\",\n      ],\n      descriptions: [\n        \"Dijkstra’s Algorithm works by visiting vertices in the graph starting with the object’s starting point. It is guaranteed to find a shortest path from the starting point to the goal.\",\n        \"A* is just like Dijkstra, the only difference is that A* tries to look for a better path by using a heuristic function which gives priority to nodes that are supposed to be better than others while Dijkstra's just explore all possible paths. A* Search will always guarantee the shortest path.\",\n        \"We say that BFS is the algorithm to use if we want to find the shortest path in an undirected, unweighted graph. The claim for BFS is that the first time a node is discovered during the traversal, that distance from the source would give us the shortest path.\",\n        \"Depth First Search (DFS) algorithm traverses a graph in a depthward motion and uses a stack to remember to get the next vertex to start a search, when a dead end occurs in any iteration. It does NOT guarantee the shortest path\",\n        \"Search Algorithm inspired by the infamous BogoSort. Has no real life application. Definitely does NOT guarantee the shortest path.\",\n        \"Based on Bogo Search. Spreads out randomly rather than traversing like a snake. Definitely does NOT guarantee the shortest path.\",\n      ],\n      links: [\n        \"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\",\n        \"https://en.wikipedia.org/wiki/A*_search_algorithm\",\n        \"https://en.wikipedia.org/wiki/Breadth-first_search\",\n        \"https://en.wikipedia.org/wiki/Depth-first_search\",\n        \"https://en.wikipedia.org/wiki/Bogosort\",\n        \"https://en.wikipedia.org/wiki/Bogosort\",\n      ],\n    };\n    return (\n      <div>\n        <nav className=\"navbar navbar-expand-lg navbar-dark bg-dark \">\n          <a className=\"navbar-brand\" href=\"/\">\n            <b>7 Days, 7 Projects - Pathfinding Visualizer (Day 1/7)</b>\n          </a>\n\n          <button\n            className=\"navbar-toggler\"\n            type=\"button\"\n            data-toggle=\"collapse\"\n            data-target=\"#navbarNav\"\n            aria-controls=\"navbarNav\"\n            aria-expanded=\"false\"\n            aria-label=\"Toggle navigation\"\n          >\n            <span className=\"navbar-toggler-icon\"></span>\n          </button>\n          <div className=\"collapse navbar-collapse\" id=\"navbarNav\">\n            <ul className=\"navbar-nav\">\n              <li className=\"nav-item\">\n                <a className=\"nav-link\" href=\"https://jj1.dev/projects\">\n                  More Projects\n                </a>\n              </li>\n            </ul>\n          </div>\n        </nav>\n\n        <div class=\"card\" style={{ width: 18 + \"rem\" }}>\n          <div class=\"card-body\">\n            <h5 class=\"card-title\">{Algos.titles[this.state.algoNum]}</h5>\n            <p class=\"card-text\">{Algos.descriptions[this.state.algoNum]}</p>\n            <a\n              href={Algos.links[this.state.algoNum]}\n              class=\"btn btn-primary\"\n              style={{ marginTop: -25 + \"px\" }}\n            >\n              Learn More\n            </a>\n          </div>\n        </div>\n\n        <div class=\"card\" id=\"legend\" style={{ width: 18 + \"rem\" }}>\n          <div class=\"card-body\">\n            <h5 class=\"card-title\">Legend</h5>\n            <div class=\"legend-row\">\n              <div style={{ color: \"green\" }} class=\"legend-square\">\n                &#9632;\n              </div>\n              <p class=\"legend-p\"> = Start Node (Click and drag)</p>\n            </div>\n            <div class=\"legend-row\">\n              <div style={{ color: \"red\" }} class=\"legend-square\">\n                &#9632;\n              </div>\n              <p class=\"legend-p\"> = End Node (Click and drag)</p>\n            </div>\n            <div class=\"legend-row\">\n              <div style={{ color: \"rgb(12, 53, 71)\" }} class=\"legend-square\">\n                &#9632;\n              </div>\n              <p class=\"legend-p\"> = Wall (Click and drag)</p>\n            </div>\n            <div class=\"legend-row\">\n              <div style={{ color: \"#40E374\" }} class=\"legend-square\">\n                &#9632;\n              </div>\n              <p class=\"legend-p\"> = Visited Node</p>\n            </div>\n            <div class=\"legend-row\">\n              <div style={{ color: \"#FFFE6A\" }} class=\"legend-square\">\n                &#9632;\n              </div>\n              <p class=\"legend-p\"> = Path to End Node</p>\n            </div>\n          </div>\n        </div>\n\n        <button\n          type=\"button\"\n          className=\"btn btn-danger\"\n          onClick={() => this.clearGrid()}\n        >\n          Clear Grid\n        </button>\n        <button\n          type=\"button\"\n          className=\"btn btn-warning\"\n          onClick={() => this.clearWalls()}\n        >\n          Clear Walls\n        </button>\n        <button\n          type=\"button\"\n          className=\"btn btn-primary\"\n          onClick={() => this.visualize(\"Dijkstra\")}\n        >\n          Dijkstra's\n        </button>\n        <button\n          type=\"button\"\n          className=\"btn btn-primary\"\n          onClick={() => this.visualize(\"AStar\")}\n        >\n          A*\n        </button>\n        <button\n          type=\"button\"\n          className=\"btn btn-primary\"\n          onClick={() => this.visualize(\"BFS\")}\n        >\n          Breadth First Search\n        </button>\n        <button\n          type=\"button\"\n          className=\"btn btn-primary\"\n          onClick={() => this.visualize(\"DFS\")}\n        >\n          Depth First Search\n        </button>\n        <button\n          type=\"button\"\n          className=\"btn btn-primary\"\n          onClick={() => this.visualize(\"Bogo\")}\n        >\n          Bogo Search\n        </button>\n        <button\n          type=\"button\"\n          className=\"btn btn-primary\"\n          onClick={() => this.visualize(\"Spread\")}\n        >\n          Random Spread\n        </button>\n        {this.state.isDesktopView ? (\n          <button\n            type=\"button\"\n            className=\"btn btn-light\"\n            onClick={() => this.toggleView()}\n          >\n            Mobile View\n          </button>\n        ) : (\n          <button\n            type=\"button\"\n            className=\"btn btn-dark\"\n            onClick={() => this.toggleView()}\n          >\n            Desktop View\n          </button>\n        )}\n\n        <table\n          className=\"grid-container\"\n          onMouseLeave={() => this.handleMouseLeave()}\n        >\n          <tbody className=\"grid\">\n            {grid.map((row, rowIdx) => {\n              return (\n                <tr key={rowIdx}>\n                  {row.map((node, nodeIdx) => {\n                    const { row, col, isFinish, isStart, isWall } = node;\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        col={col}\n                        isFinish={isFinish}\n                        isStart={isStart}\n                        isWall={isWall}\n                        mouseIsPressed={mouseIsPressed}\n                        onMouseDown={(row, col) =>\n                          this.handleMouseDown(row, col)\n                        }\n                        onMouseEnter={(row, col) =>\n                          this.handleMouseEnter(row, col)\n                        }\n                        onMouseUp={() => this.handleMouseUp(row, col)}\n                        row={row}\n                      ></Node>\n                    );\n                  })}\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n}\n\n/******************** Create Walls ********************/\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  // mouseDown starts to act strange if I don't make newGrid and work off of grid instead.\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  if (!node.isStart && !node.isFinish && node.isNode) {\n    const newNode = {\n      ...node,\n      isWall: !node.isWall,\n    };\n    newGrid[row][col] = newNode;\n  }\n  return newGrid;\n};\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called after the pathfinding methods.\nfunction getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\n\nexport function bfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  let nextNodesStack = [startNode];\n  while (nextNodesStack.length) {\n    const currentNode = nextNodesStack.shift();\n    if (currentNode === finishNode) return visitedNodesInOrder;\n\n    if (\n      !currentNode.isWall &&\n      (currentNode.isStart || !currentNode.isVisited)\n    ) {\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n      const { col, row } = currentNode;\n      let nextNode;\n      if (row > 0) {\n        nextNode = grid[row - 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n\n      if (row < grid.length - 1) {\n        nextNode = grid[row + 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n\n      if (col > 0) {\n        nextNode = grid[row][col - 1];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col < grid[0].length - 1) {\n        nextNode = grid[row][col + 1];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n    }\n  }\n}\n","// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\n\nexport function dfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  const nextNodesStack = [];\n  nextNodesStack.push(startNode);\n  while (nextNodesStack.length) {\n    const currentNode = nextNodesStack.pop();\n\n    if (currentNode === finishNode) {\n      return visitedNodesInOrder;\n    }\n\n    if (\n      !currentNode.isWall &&\n      (currentNode.isStart || !currentNode.isVisited)\n    ) {\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n\n      const { col, row } = currentNode;\n      let nextNode;\n      if (row > 0) {\n        nextNode = grid[row - 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n\n      if (row < grid.length - 1) {\n        nextNode = grid[row + 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n\n      if (col > 0) {\n        nextNode = grid[row][col - 1];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col < grid[0].length - 1) {\n        nextNode = grid[row][col + 1];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n    }\n  }\n}\n","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function bogo(grid, startNode, finishNode) {\r\n  function getRandomInt(max) {\r\n    return Math.floor(Math.random() * max);\r\n  }\r\n\r\n  const visitedNodesInOrder = [];\r\n  const nextNodesStack = [];\r\n  nextNodesStack.push(startNode);\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.pop();\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n\r\n      const { col, row } = currentNode;\r\n      let nextNode;\r\n      if (row > 1) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + getRandomInt(2)][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n\r\n      if (col > 1) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + getRandomInt(2)];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function spread(grid, startNode, finishNode) {\r\n  function getRandomInt(max) {\r\n    return Math.floor(Math.random() * max);\r\n  }\r\n\r\n  const visitedNodesInOrder = [];\r\n  const nextNodesStack = [];\r\n  nextNodesStack.push(startNode);\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.shift();\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n\r\n      const { col, row } = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + getRandomInt(2)][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + getRandomInt(2)];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import React from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}